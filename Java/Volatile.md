在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色，volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

### volatile 的官方定义

Java 语言规范第三版中对 volatile 的定义如下： java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成 volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。

### 为什么要使用 volatile

volatile 变量修饰符如果使用恰当的话，它比 synchronized 的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。


被 volatile 修饰的共享变量进行写操作的时候会多一行 lock 前缀的汇编代码，lock 前缀的指令在多核处理器下会引发了两件事情：

* 将当前处理器缓存行的数据会写回到系统内存。
* 这个写回内存的操作会引起在其他 CPU 里缓存了该内存地址的数据无效。

处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（ L1,L2 或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。


**Note:** volatile 比 synchronized 弱，只能保证可见性，不能保证操作的原子性，在不符合以下两条规则的运算场景中，我们需要通过加锁(使用 synchronized 或 java.util.concurrent 中的原子类)来保证原子性。
* 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
* 变量不需要与其他的状态变量共同参与不变约束
