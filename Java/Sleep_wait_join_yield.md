## sleep()
使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有 synchronized 同步快，其他线程仍然不能访问共享数据。

sleep() 可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

## wait() 和 notify()、notifyAll()
wait() 方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入 synchronized 数据块，当前线程被放入对象等待池中。当调用 notify() 方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则 notify() 不起作用。notifyAll() 则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。

**注意： 这三个方法都是 java.lang.Object 的方法。**

## yield()
yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的。yield() 也不会释放锁标志。

实际上，yield() 方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给次线程，否则继续运行原来的线程，所以 yield() 方法称为“退让”，它把运行机会让给了同等级的其他线程。

sleep 方法允许较低优先级的线程获得运行机会，但 yield()方法执行时，当前线程仍处在可运行状态，所以不可能让出较低优先级的线程此时获取 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，也没有受到 I/O 阻塞，那么较低优先级线程只能等待所有较高优先级的线程运行结束，方可有机会运行。

yield() 只是使当前线程重新回到可执行状态，所有执行 yield() 的线程有可能在进入到可执行状态后马上又被执行，所以 yield() 方法只能使同优先级的线程有执行的机会。

## join()
join() 方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。
